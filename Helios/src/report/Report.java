/**
 * 
 */
package report;

import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Vector;

import logging.LogIDManager;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.MDC;
import org.apache.log4j.NDC;

import util.DateParser;
import util.ParameterValidator;
import exceptions.ReportSetupException;

/**
 * Architecture for building reports. 
 * 
 * @author Jason Diamond
 *
 */
public abstract class Report 
{
	protected Logger logger;
	protected String reportName;
	protected DateParser dateParser;

	//verifiable here
	public final static String START_DATE_PARAM = "startDate";
	public final static String END_DATE_PARAM = "endDate";
	public final static String ROSTER_TYPE_PARAM = "rosterType";
	public final static String TIME_GRAIN_PARAM = "timeGrain";
	public final static String AGENT_NAME_PARAM = "agentName";
	public final static String NUM_DRIVERS_PARAM = "numDrivers";
	
	protected boolean isTimeReport = false;
	
	public static final int AGENT_STACK_REPORT = 1;
	public static final int AGENT_TIME_REPORT = 2;
	public static final int TEAM_STACK_REPORT = 3;
	public static final int TEAM_TIME_REPORT = 4;

	//only verifiable in child classes
	public final static String REPORT_TYPE_PARAM = "reportType";
	
	private final String LOGGER_HANDLE = "reporting";

	protected HashMap<String,String> parameters;

	private String errorMsg;
	protected boolean isChildReport;
	
	protected String logID; 
	protected final String LOG_ID_PREFIX = "id=";

	/**
	 * Build the stuff that every report should want. Specifically a logger, and each report's prerequisite resources like database connections and rosters. The actual data store 
	 * interaction is best left to implementing subclasses. 
	 * 
	 * @throws ReportSetupException		A report will necessarily have a data source, so we need to enforce passing problems with establishing a connection up to the calling layer. In this case, that's the BIRT viewer.
	 */
	protected Report() throws ReportSetupException
	{
		logID = LogIDManager.getLogID().toString();
		
		//attach log id to messages
		if(MDC.get(LOG_ID_PREFIX) == null)
		{
			MDC.put(LOG_ID_PREFIX, LOG_ID_PREFIX + logID);
		}
		
		dateParser = new DateParser();
		
		isChildReport = false;
		
		if(!setupReport() || !setupDataSourceConnections() || dateParser == null)
		{
			throw new ReportSetupException("Report setup failed.");
		}
		
		logger = Logger.getLogger(LOGGER_HANDLE);
		
		errorMsg = "";

		parameters = new HashMap<String, String>();
	}

	/** 
	 * Attempt to establish connections to all required datasources. A report by definition has at least one, and possibly many.
	 * 
	 * @return	True if the connection was established, false otherwise.
	 */
	protected abstract boolean setupDataSourceConnections();

	/** 
	 * Attempt to fulfill the prerequisites of the report. A common one will be building the report's roster.
	 * 
	 * @return	True if the setup was run successfully, false otherwise.
	 */
	protected abstract boolean setupReport();

	/**
	 * Process the report.
	 * 
	 * @return	The result set, null if the report fails.
	 */
	public Vector<String[]> startReport()
	{
		logger.log(Level.INFO, "Running report " + toString());
		
		Vector<String[]> retval = new Vector<String[]>(0);
		if(validateParameters())
		{
			try
			{
				retval =  runReport();
				
				logger.log(Level.INFO, "Report " + reportName + " returning rows: " + retval.size());
			}
			catch (Throwable e)
			{
				StringBuilder stackTrace = new StringBuilder();	
				stackTrace.append("Exception: " + e.getClass().getCanonicalName() + ": " + e.getMessage() + "\n");

				errorMsg = stackTrace.toString();

				for(StackTraceElement st : e.getStackTrace())
				{
					stackTrace.append(st.toString());
					stackTrace.append("\n");
				}

				logger.log(Level.ERROR, stackTrace.toString());
				
				e.printStackTrace();
			}
		}
		else
		{
			errorMsg = "Parameter validation failed. Double-check report parameters.";
			logger.log(Level.ERROR, errorMsg);
		}

		return retval;
	}

	/**
	 * Retrieve any error messages.
	 * 
	 * @return	The error message string.
	 */
	public String getErrorMsg()
	{
		return errorMsg;
	}

	/**
	 * Process the child report. Only report.startReport should call this.
	 * 
	 * 
	 * @return	The result set.
	 * 
	 * @throws 	Any exception generated by children, up to its caller, startReport() or another proper handling mechanism
	 * 
	 */
	protected abstract Vector<String[]> runReport() throws Exception;
	
	/**
	 * Validate the report's parameters. Each implementor of Report could possibly validate parameters differently.
	 *  
	 * @return	True if the report's parameters are valid and viable to run the report. False otherwise.
	 */
	protected abstract boolean validateParameters();

	/**
	 * Close the report. Subclasses (reports) need to run super.close() to hit this, any resources owned by Report bleed out.
	 */
	public void close()
	{
		logger.log(Level.INFO, "Closing report: " + reportName);

		//child reports shouldn't be able to close the logger's filehandlers, save that for the parent report

		//shutdown the logger
		//on second thought, don't shutdown the logger. log4j runs it kind of like a connection pool maintained by the java proc
		//close it via termination of the java process or by cycling tomcat, very important a tomcat restart terms the java proc
		if(!isChildReport)
		{
			//LogManager.shutdown();
			MDC.getContext().clear();
		}
	}
	
	/**
	 * Mark the report as a child or parent report.
	 * 
	 * @param isChild	True if the report is a child of another report, false otherwise.
	 */
	public void setChildReport(boolean isChild)
	{
		isChildReport = isChild;
		
		if(isChildReport)
		{
			NDC.pop();
		}
	}
	
	/**
	 * Validate the report's time grain parameters.
	 *  
	 * @return	True if the time grain parameter are valid and viable to run the report. False otherwise.
	 */
	protected boolean hasValidTimeGrain()
	{
		return hasValidTimeGrain(new int[]{DateParser.YEARLY_GRANULARITY, DateParser.MONTHLY_GRANULARITY, DateParser.WEEKLY_GRANULARITY, DateParser.DAILY_GRANULARITY, DateParser.HOURLY_GRANULARITY});
	}
	
	/**
	 * Validate the report's time grain parameter against a list of acceptable values.
	 *  
	 *  @param validValues		A list of acceptable values.
	 *  
	 * @return	True if the time grain parameter are valid and viable to run the report. False otherwise.
	 */
	
	protected boolean hasValidTimeGrain( int[] validValues)
	{
		boolean retval = false;

		if( parameters.containsKey(TIME_GRAIN_PARAM))
		{
			String timeGrainStr = parameters.get(TIME_GRAIN_PARAM);
			try
			{
				retval = ParameterValidator.validateTimeGrain(Integer.parseInt(timeGrainStr), validValues);
			}
			catch (Throwable t)	{}
			finally
			{
				if(retval)
				{
					logger.log(Level.INFO, "Confirmed coherent report time granularity: " + timeGrainStr);		
				}
				else
				{
					logger.log(Level.ERROR,  "Unexpected report time granularity: " + timeGrainStr );
				}
			}
		}
		else
		{
			logger.log(Level.ERROR,  "Time granularity parameter missing, aborting report" );
		}
		
		return retval;
	}
	
	/**
	 * Validate the report's date interval parameters.
	 *  
	 * @return	True if the date interval parameters are valid and viable to run the report. False otherwise.
	 */

	protected boolean hasValidDateInterval()
	{
		boolean retval = false;

		if(parameters.containsKey(START_DATE_PARAM) && parameters.containsKey(END_DATE_PARAM))
		{
			String startDate = getParameter(START_DATE_PARAM);
			String endDate = getParameter(END_DATE_PARAM);
			
			try
			{
				GregorianCalendar now = new GregorianCalendar();
				
				if(startDate.equalsIgnoreCase("now"))
				{
					startDate = dateParser.readableGregorian(now);
					setParameter(START_DATE_PARAM, startDate);
				}
				
				if(endDate.equalsIgnoreCase("now"))
				{
					endDate = dateParser.readableGregorian(now);
					setParameter(END_DATE_PARAM, endDate);
				}
				
				retval = ParameterValidator.validateDateInterval(startDate, endDate);
			}
			catch (Exception e) {}
			finally
			{
				if(retval)
				{
					logger.log(Level.INFO, "Confirmed coherent date interval: " + startDate + ", " + endDate);
				}
				else
				{
					logger.log(Level.ERROR,  "Invalid report time interval: " + startDate +" => " + endDate + ", aborting report" );
				}
			}
		}
		else
		{
			logger.log(Level.ERROR,  "Start date and/or End date parameters missing, aborting report" );
		}

		return retval;
	}
	

	/**
	 * Validate the report's date interval parameter against a list of acceptable values.
	 *  
	 *  @param validTypes		A list of acceptable values.
	 *  
	 * @return	True if the date interval parameters are valid and viable to run the report. False otherwise.
	 */
	protected boolean isValidReportType(int[] validTypes)
	{
		boolean retval = false;

		if(parameters.containsKey(REPORT_TYPE_PARAM))
		{
			String reportTypeStr = parameters.get(REPORT_TYPE_PARAM);
			
			try
			{
				retval = ParameterValidator.validateReportType(Integer.parseInt(reportTypeStr), validTypes);
			}
			catch (Exception e)	{}
			finally
			{
				if(retval == false)
				{
					logger.log(Level.ERROR,  "Unexpected report type: " + reportTypeStr );
				}
				else
				{
					logger.log(Level.INFO, "Confirmed coherent report type: " + reportTypeStr);
				}
			}
		}
		else
		{
			logger.log(Level.ERROR,  "Report type parameter missing, aborting report" );
		}

		return retval;
	}
	
	/**
	 * Validate the report's number-of-drivers parameter.
	 *  
	 * @return	True if the number-of-drivers parameter are valid and viable to run the report. False otherwise.
	 */

	protected boolean isValidNumDrivers()
	{
		boolean retval = false;

		if(parameters.containsKey(NUM_DRIVERS_PARAM))
		{
			try
			{
				int numDrivers = Integer.parseInt(parameters.get(NUM_DRIVERS_PARAM));
				if(	numDrivers > 0)
				{
					retval = true;
					logger.log(Level.INFO, "Confirmed coherent report num Drivers: " + numDrivers);
				}
				else
				{
					logger.log(Level.ERROR, "Unexpected num Drivers: " + numDrivers );
				}
			}
			catch (NumberFormatException e)	{}
			finally
			{
				if(retval == false)
				{
					logger.log(Level.ERROR,  "Unexpected num Drivers: " + parameters.get(NUM_DRIVERS_PARAM) );
				}
			}
		}
		else
		{
			logger.log(Level.ERROR,  "Num Drivers parameter missing, aborting report" );
		}
		
		return retval;
	}
	
	/**
	 * Generate a string that summarizes this report object. Information includes report name, parameters defined and their respective values, if any. Useful in logging.
	 *  
	 * @return	The summary string.
	 */
	
	public String toString()
	{
		StringBuilder output = new StringBuilder();

		output.append(reportName + " with parameters: ");

		for(Entry<String, String> param  : parameters.entrySet())
		{
			output.append(param.getKey());
			output.append(" => ");
			output.append(param.getValue());
			output.append(", ");
		}

		return output.toString();
	}
	
	/**
	 * Set a named report parameter to the supplied value. 
	 * 
	 * @param key			Report parameter name.
	 * @param value		Parameter value..
	 * 
	 */

	public void setParameter(String key, String value)
	{
		parameters.put(key, value);
	}

	/**
	 * Set a named report parameter to the supplied value. The parameter hashmap is a string => string mapping, so this is a shortcut method that will convert an int value to a string.  
	 * 
	 * @param key			Report parameter name.
	 * @param value		Parameter value.
	 * 
	 */
	public void setParameter(String key, int value)
	{
		setParameter(key, "" + value);
	}
	
	/**
	 * Retrieve a named report parameter to the supplied value.
	 * 
	 * @param key			Report parameter name.
	 * 
	 * @return	Value stored by the parameter, if any.
	 */
	
	public String getParameter(String key)
	{
		return parameters.get(key);
	}
	
	/**
	 * Determine if this report is a time-centric (AGENT_TIME/TEAM_TIME) report.
	 *  
	 * @return	True if the report is a time-centric report. False otherwise.
	 */
	
	public boolean isTimeReport()
	{
		return isTimeReport;
	}
	
	/**
	 * Set this report's log ID
	 * 
	 * @param logID			Log ID to apply to this report.
	 * 
	 */
	
	public void setLogID(String logID)
	{
		this.logID = logID;
	}
	
}
